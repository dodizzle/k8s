package main

import (
	"bufio"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/olekukonko/tablewriter"
)

var (
	kubeCtl = "/Users/daveo/KUBE/google-cloud-sdk/bin/kubectl"
	gcloud  = "/Users/daveo/KUBE/google-cloud-sdk/bin/gcloud"
)

func main() {

	args := os.Args

	// print usage
	if len(args[1:]) < 1 {
		fmt.Println("Usage: ", args[0], "-p (change project) || -c (change context) || -t (generate token for proxy auth)")
		os.Exit(0)
	}

	if args[1] == "-c" {
		context := getContexts(kubeCtl)
		setContext(context)
	} else if args[1] == "-t" {
		defaultSecret := getDefaultSecret()
		defaultToken := getDefaultToken(defaultSecret)
		decodeToken(defaultToken)
	} else if args[1] == "-p" {
		project := getProjects(gcloud)
		setProject(project, gcloud)
	}
}

func setProject(project string, gcloud string) {
	out, err := exec.Command(gcloud, "config", "configurations", "activate", project).Output()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(out))
}

func getProjects(gcloud string) string {
	filter := `--format=value(name.scope())`
	//out, err := exec.Command(gcloud, "config", "configurations", "list", "--format='value(name.scope())'").Output()
	out, err := exec.Command(gcloud, "config", "configurations", "list", filter).Output()
	if err != nil {
		log.Fatal(err)
	}
	dat := string(out)

	lines := strings.Split(dat, "\n")

	contextsReturn := map[int][]string{}
	startingNum := 0
	// remove header from cli output
	//lines = append(lines[:0], lines[0+1:]...)
	// remove the last slice which is empty
	lines = lines[:len(lines)-1]

	for _, l := range lines {
		startingNum++
		contextsReturn[startingNum] = []string{l}
	}

	contextsTable := tablewriter.NewWriter(os.Stdout)
	contextsTable.SetHeader([]string{"", "Configurations"})

	var keys []int
	for k := range contextsReturn {
		keys = append(keys, k)
	}
	sort.Ints(keys)
	for _, k := range keys {
		contextsTable.Append([]string{strconv.Itoa(k), contextsReturn[k][0]})
	}
	contextsTable.Render()
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Context to use? ")
	contextsIndex, _ := reader.ReadString('\n')

	contextChoice, erry := strconv.Atoi(strings.TrimSpace(contextsIndex))
	if erry != nil {
		fmt.Println("Error:", err)
	}
	return (contextsReturn[contextChoice][0])
}

func BytesToString(data []byte) string {
	return string(data[:])
}

func decodeToken(defaultToken string) {
	data, err := base64.StdEncoding.DecodeString(defaultToken)
	if err != nil {
		fmt.Println("error:", err)
		return
	}
	cleanToken := BytesToString(data)
	fmt.Println("Copy and paste this:")
	fmt.Println(cleanToken)
}

func getDefaultToken(defaultSecret string) string {
	out, err := exec.Command("/Users/daveo/KUBE/google-cloud-sdk/bin/kubectl", "get", "secret", defaultSecret, "-o", "json").Output()
	if err != nil {
		log.Fatal(err)
	}
	type AutoGenerated struct {
		APIVersion string `json:"apiVersion"`
		Data       struct {
			CaCrt     string `json:"ca.crt"`
			Namespace string `json:"namespace"`
			Token     string `json:"token"`
		} `json:"data"`
		Kind     string `json:"kind"`
		Metadata struct {
			Annotations struct {
				KubernetesIoServiceAccountName string `json:"kubernetes.io/service-account.name"`
				KubernetesIoServiceAccountUID  string `json:"kubernetes.io/service-account.uid"`
			} `json:"annotations"`
			CreationTimestamp time.Time `json:"creationTimestamp"`
			Name              string    `json:"name"`
			Namespace         string    `json:"namespace"`
			ResourceVersion   string    `json:"resourceVersion"`
			SelfLink          string    `json:"selfLink"`
			UID               string    `json:"uid"`
		} `json:"metadata"`
		Type string `json:"type"`
	}
	var result AutoGenerated
	json.Unmarshal([]byte(out), &result)
	return result.Data.Token
}

func getDefaultSecret() string {
	out, err := exec.Command("/Users/daveo/KUBE/google-cloud-sdk/bin/kubectl", "get", "sa", "default", "-o", "json").Output()
	if err != nil {
		log.Fatal(err)
	}
	type AutoGenerated struct {
		APIVersion string `json:"apiVersion"`
		Kind       string `json:"kind"`
		Metadata   struct {
			CreationTimestamp time.Time `json:"creationTimestamp"`
			Name              string    `json:"name"`
			Namespace         string    `json:"namespace"`
			ResourceVersion   string    `json:"resourceVersion"`
			SelfLink          string    `json:"selfLink"`
			UID               string    `json:"uid"`
		} `json:"metadata"`
		Secrets []struct {
			Name string `json:"name"`
		} `json:"secrets"`
	}
	var result AutoGenerated
	json.Unmarshal([]byte(out), &result)
	return result.Secrets[0].Name
}

func setContext(context string) {
	out, err := exec.Command("/Users/daveo/KUBE/google-cloud-sdk/bin/kubectl", "config", "use-context", context).Output()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(out))
}

func getContexts(kubeCtl string) string {
	out, err := exec.Command("/Users/daveo/KUBE/google-cloud-sdk/bin/kubectl", "config", "get-contexts", "-o", "name").Output()
	if err != nil {
		log.Fatal(err)
	}
	dat := string(out)

	lines := strings.Split(dat, "\n")

	contextsReturn := map[int][]string{}
	startingNum := 0
	// remove header from cli output
	// lines = append(lines[:0], lines[0+1:]...)
	// remove the last slice which is empty
	lines = lines[:len(lines)-1]

	for _, l := range lines {
		startingNum++
		contextsReturn[startingNum] = []string{l}
	}

	contextsTable := tablewriter.NewWriter(os.Stdout)
	contextsTable.SetHeader([]string{"", "Contexts"})

	var keys []int
	for k := range contextsReturn {
		keys = append(keys, k)
	}
	sort.Ints(keys)
	for _, k := range keys {
		contextsTable.Append([]string{strconv.Itoa(k), contextsReturn[k][0]})
	}
	contextsTable.Render()
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Context to use? ")
	contextsIndex, _ := reader.ReadString('\n')

	contextChoice, erry := strconv.Atoi(strings.TrimSpace(contextsIndex))
	if erry != nil {
		fmt.Println("Error:", err)
	}
	return (contextsReturn[contextChoice][0])
}
